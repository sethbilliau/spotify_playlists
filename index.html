<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="css/jquery.pagepiling.min.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="icon" href="images/spotify_icon.png">
</head>
<body>

<!-- Top nav bar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light navbar-custom">
        <a class="navbar-brand" href="#">CS 109 Project</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto" id="myMenu">
                <li data-menuanchor="firstPage" class="nav-item active">
                    <a class="nav-link" href="#firstPage">Home</a>
                </li>
                <li data-menuanchor="secondPage" class="nav-item">
                    <a class="nav-link" href="#secondPage">Abstract</a>
                </li>
                <li data-menuanchor="thirdPage" class="nav-item">
                    <a class="nav-link" href="#thirdPage">Literature Review</a>
                </li>
                <li data-menuanchor="fourthPage" class="nav-item">
                    <a class="nav-link" href="#fourthPage">Data and EDA</a>
                </li>
                <li data-menuanchor="fifthPage" class="nav-item">
                    <a class="nav-link" href="#fifthPage">Methods and Models</a>
                </li>
                <li data-menuanchor="sixthPage" class="nav-item">
                    <a class="nav-link" href="#sixthPage">Results</a>
                </li>
                <li data-menuanchor="seventhPage" class="nav-item">
                    <a class="nav-link" href="#seventhPage">Conclusions</a>
                </li>
                <li data-menuanchor="eighthPage" class="nav-item">
                    <a class="nav-link" href="#eighthPage">Bibliography</a>
                </li>
            </ul>
        </div>
    </nav>

<!-- Page piling, to create a new page, add a new div with class "section" -->
    <div id="pagepiling">
        <div class="section">
            <img src="images/spotify_logo.png" alt="spotify logo" class="center" width = "800">
            
            <br/>
            <h1 class="center" style="text-align: center;">Generating Playlists with Spotify</h1>
            <li>Team members: Seth Billiau, William Drew, Sarah Lucioni</li>
            <li>Assigned TF: Nathan Hollenberg</li>
            <li>Last edited: 12/11/2019</li>
            <li>Group ID: 56</li>
        </div>
        <div class="section pp-scrollable">
            <h1>Abstract</h1>
            <h3>Motivation and Project Questions</h3>
            <p>When it comes to music, streaming is the way of the future. Convenient, cheap, and widely accessible, streaming is easier than ever with more people turning to popular services for their musical needs. In April of 2019, industry leader Spotify announced that they had reached a staggering 217 million monthly active users with over 100 million paid subscribers (Porter, “Spotify Is First to 100 Million Paid Subscribers.”).</p>

            <p>In addition to providing music for its users, Spotify also provides a robust music recommendation system. Leveraging data science and machine learning techniques, Spotify aggregates a number of different models to generate new playlists based on a user’s musical preferences.</p>

            <p>Developing a user’s musical taste is no small feat, but Spotify is able to overcome this hurdle by collecting user feedback on generated playlists with an up/down vote system and by aggregating information from a user’s listening history. But what if they didn’t have all of that information?  How should Spotify generate a new playlist for a brand new user given minimal user information? Imagine a new user stumbles upon Spotify for the first time and plays a song. From this single song, is it possible to generate a likeable playlist?</p>

            <p>Our project attempts to answer this question by developing such a "cold start" model, generating a new playlist for a user given just a single song. </p>

            <h3>Organization of the Report</h3> 
            <p>After a brief literature review, this report will begin with an exploration of the dataset and its features. We will continue by explaining our methods, models, and forms of evaluation. The final sections of our project will present our results and conclusions with a brief discussion of possible extensions to our project.</p>


            <h5>Works Cited</h5>
              <ol>
                 <li>
                    <p>Porter, “Spotify Is First to 100 Million Paid Subscribers.”</p>
                 </li>
                 <li>
                    <p>“Discover Weekly: How Spotify Is Changing the Way We Consume Music – Technology and Operations Management.”</p>
                 </li>
              </ol>
        </div>
         <div class="section pp-scrollable">
            <h1>Literature Review</h1>
            <p>Before diving into our project, we reviewed various sources of relevant literature, researching different tools that could help us accomplish our project goal. First, we learned as much as we could about Spotify’s internal recommendation system.<p>

            <h3>Spotify’s Recommendation System</h3>
            <p>Spotify’s music recommendation system uses a combination of three different models when creating new playlists for existing users: Collaborative filtering, Natural Language Processing (NLP), and Audio modeling. These three methods are described below.</p>

            <h5>Collaborative Filtering</h5>
            <p>Collaborative filtering is an algorithm that predicts a user’s interests based on the interests of similar peers. Spotify leverages this technique by using its wealth of customer listening data, identifying similar individuals to a target customer and creating a new playlist with songs enjoyed by those similar individuals. For example, say Spotify knows that target user X has listened to songs 3, 4, 9, and 10 while user Y has listened to songs 1, 2, 9, and 10. Using collaborative filtering, Spotify might add songs 1 and 2 to a new playlist for user X (Johnson, “Algorithmic Music Recommendations at Spotify.”).</p>

            <h5>Natural Language Processing (NLP)</h5>
            <p>Spotify analyzes text from popular blog posts, internet data, and music publications to see which songs are being commonly discussed and if songs are frequently being discussed together. Using this text analysis, Spotify attempts to cluster descriptions and adjectives to get a sense of what people think of a given song or artist. Based on this information and past user information, Spotify will attempt to predicts new songs for a target user. For example, say target user X has listened to song 1. Based on NLP information, Spotify learns that song 1 is often discussed with song 2 and is often described as “dancey”. Therefore, Spotify might suggest song 2 in a new playlist for user X along with other songs that have been identified as “dancey” (Giacaglia, “Behind Spotify Recommendation Engine.”).</p>

            <h5>Audio modeling</h5>
            <p>Using a Convolutional Neural Network, Spotify analyzes the input raw audio of every song on the service, producing comparable characteristics like time signature, key, tempo, loudness, etc., to compare songs. Therefore, if Spotify knows a target user has listening to song 1 with certain audio features, it will suggest songs with similar audio features in a new playlist. These audio features can be accessed via the Spotify developer tools (Dieleman. “Recommending Music on Spotify with Deep Learning.”).</p>

            <p>Based on this research, we decided to explore an approach similar to Spotify’s audio modeling techniques in our project. With only a single input song, we do not have enough information on our base user to use collaborative filtering in an effective way. We also don’t have the bandwidth or capabilities to perform NLP with the tools we have learned in CS109. However, Spotify’s song audio features provide easily-comparable metrics by which to identify similar songs given one input track.</p>


            <h5>Works Cited</h5>
              <ol>
                 <li>
                    <p>Chris Johnson. “Algorithmic Music Recommendations at Spotify.” Technology, 11:33:57 UTC. <br> https://www.slideshare.net/MrChrisJohnson/algorithmic-music-recommendations-at-spotify/3-What_is_SpotifyOn_demand_music.</p>
                 </li>
                 <li>
                    <p>Giacaglia, Giuliano. “Behind Spotify Recommendation Engine.” Medium, May 21, 2019. <br> https://medium.com/datadriveninvestor/behind-spotify-recommendation-engine-a9b5a27a935.</p>
                 </li>
                 <li>
                     <p>Sander Dieleman. “Recommending Music on Spotify with Deep Learning.” Accessed December 9, 2019. <br>https://benanne.github.io/2014/08/05/spotify-cnns.html.</p>
                 </li>
              </ol>
        </div>
 
        <div class="section pp-scrollable">
            <h1>Data and EDA</h1>
            <p>Given our literature research, the goal of our data cleaning was to obtain Spotify audio features to be used for modeling in our project. This section describes that process.</p>
            <h3>Data Sources and Features</h3>
            <p>This project uses the Spotify Songs dataset, a collection of one million playlists organized into 1000 .csv files. Each row of these .csv files is a song object with the variable <i>pid</i> denoting the playlist ID and linking the corresponding song objects to the playlist. The features of our data are as follows: </p>

            <li><i>pid:</i> the song’s corresponding playlist ID </li>
            <li><i>pos:</i> the song’s position on the playlist</li>
            <li><i>artist_name:</i> the song’s artist name</li>
            <li><i>track_uri:</i> the Uniform Resource Indicator (URI) link for the song (which we can query the Spotify API with)</li>
            <li><i>artist_uri:</i>  the Uniform Resource Indicator link for the artist</li>
            <li><i>track_name:</i> the name of the song</li>
            <li><i>album_uri:</i> the Uniform Resource Indicator link for the album the song is on </li>
            <li><i>duration_ms:</i> the length of the song in ms</li>
            <li><i>album_name:</i> the name of the album the song is on</li>

            <br/>

            <p>We began by performing some preliminary analysis to explore how we can engineer these given features to our advantage. Upon an initial inspection, we saw that we needed to clean three variables: <i>track_uri, artist_uri</i>, and <i>album_uri</i>. Originally, all three of these URI's showed the header <i>“spotify:track/artist/album:URI”</i>. However, the useful part of each of these features was the URI code that followed this header since it can be used to query the Spotify API. Therefore, we wrote a function to strip off this header and reformatted these features to include only the useful parts of the URI.</p>

            <p>Using these URI’s we queried the Spotify API using the Spotipy library to access the API with Python, extracting the audio features for each song in our dataset. The audio features we plan to examine most closely are:</p>

            <li><i>acousticness:</i> [0, 1] value determining whether track is acoustic</li>
            <li><i>danceability:</i> [0, 1] value determining whether track is danceable</li>
            <li><i>duration:</i> track duration in ms</li>
            <li><i>energy:</i> [0, 1] value determining relative energy of track, typically classical to heavy metal, soft to intense/loud/full of activity </li>
            <li><i>instrumentalness:</i> [0, 1] value determining whether track has vocal content, closer to 1 is closer to instrumental </li>
            <li><i>liveness:</i> [0, 1] value determining whether track is recorded in front of a live audience</li>
            <li><i>loudness:</i> how loud the song is in decibels (dB). Typically -60 to 0 db</li>
            <li><i>mode:</i> [0, 1] value determining whether track is more minor or major</li>
            <li><i>speechiness:</i> [0, 1] value determining spoken words in track (below 0.33 likely represents music, non-spoken tracks) </li>
            <li><i>tempo:</i> song's tempo in beats per minute (BPM) </li>
            <br/>
            
            <p>When parsing the playlists, we ran into some problems where occasionally the Spotify API did not return a complete audio feature list when provided with specific song URIs. This prevented the entire playlist from being parsed correctly, so we handled this problem by skipping these playlists whenever we ran into this issue. We do not believe that this has any significant impact on the collection of songs we compiled as we could not identify any systematic pattern nor commonality between the problematic playlists. </p>

            <p>From our dataset of one million playlists, we parsed 30,000 of them and collected audio features for nearly 200,000 songs. We stopped at parsing through only 30,000 playlists due to technical limitations and time constraints. By our estimation, it would have taken us multiple days and memory usage beyond the capabilities of our laptops to parse through all one million playlists. Of course, by limiting the number of playlists we parsed, we are limiting the size of our music library that we can recommend. We decided that the first 30,000 playlists mapping to 200,000 songs provided a good enough distribution of music genres, types, and styles to provide interesting and novel recommendations to our users. </p>

            <p> </p>
            <br/>
            <h3>EDA</h3>
            <p>After successfully extracting audio features for each song in our dataset, we began by visualizing the distribution of these audio features. 

            We then wrote a function to extract a list of the tracks in a playlist and another function to return summary statistics about the playlist’s audio features. The latter function uses the Spotify API to extract the audio features of each song in the playlist. Based on the audio features, we further explored the data by creating visualizations which are displayed in the following section. We also created visualizations based on the number of songs in a playlist and the duration (in minutes) of a playlist.</p>
            <p> </p>
            <br/>

        </div>

        <div class="section pp-scrollable">
            <h1>Methods and Models</h1>
            <h3>Model Type and Description</h3>
            <p>To address our question of how to generate a new playlist for a new user given minimal user information, we first considered the data we would use, the transformations we would need to apply, the output we wanted, and the input needed to predict the output before deciding on a model type. Rewording our problem statement, our model must predict a playlist given minimal user information.</p>

            <h3>Data</h3>
            <p>The data is unconventional because our data of playlists of songs are technically categorical data. However, each unique song is it’s own “category” which makes traditional categorical transformations such as one-hot encoding uninterpretable. Using the Spotify API, we can extract audio features for each song (see Data and EDA). The audio features transform each song to a set of numerical features better suited for traditional prediction techniques. We selected the audio features acousticness, danceability, energy, instrumentalness, liveness, speechiness, and tempo to analyze. We chose these seven features because they are rarely omitted from the Spotify audio features data (an omitted audio feature appears as a 0 in the Spotify data) and they are all normalized values (except tempo). Tempo not being normalized led to several model variations which we will discuss below.</p>
            <p>As discussed in the Data and EDA section, our dataset contains one million playlists. To reduce the computational power needed and the Spotify API calls made, we decided to train our model on the first 30,000 playlists and test on the next 1000 playlists. This train - test split is valid because the data is already randomly sorted. Therefore, both the train and test sets should reflect the overall data.</p>

            <h3>Response and Predictor Variables</h3>
            <p>The output is an n-length playlist of n-songs. This means that our model should predict n-songs. To do so, our transformed song data (to audio features) should also keep a reference back to it’s song. This reference will be used to display the predicted playlist. </p>
            <p>The input needs to be a datum that our model can predict songs based off of, but it must be minimal to match our problem statement. Due to these constraints, we decided that our input would be a “seed song” as well as a playlist length. The seed song will be in the form of a Spotify URI so that we can extract the audio features from it. We also input a playlist length to simplify the predictive tasks of the model. However, a separate model could be written to predict the length of the playlist, but we did not find this necessary to implement to address our problem statement. <p>
            <p>Therefore, our model must predict an n-length playlist of n-songs given n and a seed song.<p>

            <h3>Model</h3>
            <p>With one seed song, a natural approach suggests creating a playlist from the n closest songs to the seed. This motivates our first set of models: <b>k-Nearest Neighbors</b> based. Our second set of models is a logical comparison to the first: <b>k-Means Clustering</b> based. Let us first define each type of model, then discuss the differences, and finally, present our constructed models.<p>

            <h3>k-Nearest Neighbors</h3>
            <p>k-NN models are supervised machine learning algorithms used for classification or regression. Typically, the k nearest neighbors are accessed to predict the classification (most frequently occurring class in the k) or regression (mean of the k nearest neighbors). The k-NN algorithm is an instance of lazy learning which means that the computation is deferred until it must output a prediction (“Machine Learning Basics with the K-Nearest Neighbors Algorithm”). One variation of a k-NN model is the choice of distance metric. A proper distance metric must satisfy three properties:</p>

            <ol>
              <li>d(x, x) = 0, The distance between the same point equals 0.</li>
              <li>d(x, x’) = d(x’, x), The distance function must be symmetric.</li>
              <li>d(x, x’’)  d(x, x’) + d(x’, x’’), The triangle inequality must hold.</li>
            </ol>

            <p>Euclidean distance is commonly the selected distance metric for k-NN. However, cosine similarity may be effective in some cases. Cosine similarity does not respect the above properties, but may be used as a distance metric if appropriately treated within the model. The choice of distance metric presents the first variation in our set of k-NN models. We create one set of models using euclidean distance and a second set using cosine similarity.</p>
            <p>Due to the distance metric, k-NN typically performs best when the data is all on the same scale (Dhiraj, “Difference between K-Nearest Neighbor(K-NN) and K-Means Clustering”). This limitation raises a concern about training our k-NN models on our data including tempo. The other six features are on a [0, 1] scale. However, tempo varies greatly and is hard to normalize because there is not a common base or top value. This presents a second variation in our set of k-NN models: include vs. omit tempo from the training data. </p>
            <p>In our set of k-NN based models, instead of computing an averaged prediction from the k nearest neighbors, our prediction <i>will</i> be the k nearest neighbors. Furthermore, <i>k = n</i> (where n is one of the input parameters).</p>
            <p>In the future, possible improvements include creating a weighted k-NN model. The songs could be weighted by popularity/occurrence in the training set, how close they are to the original song, or by some other feature we wish to include. </p>

            <h3>k-Means Clustering</h3>
            <p>k-Means Clustering is unsupervised machine learning algorithm which aims to split n observations (songs) into k clusters based on the nearest mean. k-Means is an NP-hard problem which means that it is computationally difficult to find the best answer (“K-Means Clustering”). Problems in NP are believed to not be solvable in polynomial time, however, this has not been proven (“Rocchio Algorithm”). However, efficient algorithms which converge to a local optimum exist.</p>

            <p>k-Means can work well even when data is not on the same scale. To be consistent with our k-NN based models, we will construct a set of k-Means models which include vs. omit tempo from the training data. </p>
            <p>Since we want our model to predict a playlist, we will have to slightly modify our k-Means model. To do so, we will construct a k-Means model, then we will predict the cluster the seed song belongs to. This cluster will become the selected cluster. A random sample of <i>n</i> songs will be drawn from the cluster and will create the predicted playlist. We randomly select the songs from the predicted cluster so as to better test the clustering functionality of the k-Means model.  </p>
            <p>In the future, we could implement a smarter selection criteria for selecting songs within a cluster. A smarter choice would be to implement a k-NN model within a cluster to select the <i>n</i> songs. This variation is known as the Rocchio algorithm (“Rocchio Algorithm”). We did not want to test this variation because it blurs the line between k-NN and k-Means which we wish to keep clear for the sake of our model comparisons.</p>
            <h3>k-Nearest Neighbors vs. k-Means Clustering</h3>
            <p>There are a few clear differences between the k-NN and k-Means algorithms. First, k-NN solves a classification or regression problem while k-Means solves a clustering problem. Second, as explained above, k-NN is a lazy learner while k-Means is an eager learner. A lazy learner saves computation until absolutely needed as we observe in k-NN. An eager learner has a training step which creates and fits a model. Finally, as discussed above, k-NN functions much better if the data is all on the same scale while k-Means does not have this same constraint (Dhiraj).</p>
            <p>Comparing these two sets of models allows us to compare a human tailored selection model (k-NN based) to a computer selection model (k-Means Clustering based). We will use this comparison as a testing metric discussed in the Results section. </p>

            <h3>Final Models</h3>
            <p>Our k-NN models will have two variantes: distance metric and tempo. This leads to four k-NN models total. The four models are:</p>
            <ol>
                <li>k-NN using <b>Euclidean distance</b> and <b>raw</b> tempo</li>
            <li>k-NN using <b>Euclidean distance</b> and <b>no</b> tempo</li>
            <li>k-NN using <b>cosine similarity</b> and <b>raw</b> tempo</li>
            <li>k-NN using <b>cosine similarity</b> and <b>no</b> tempo</li>
            </ol>

            <p>We decided to omit comparison to normalized tempo after testing normalized tempo and seeing that the playlists constructed with tempo normalized typically consist of songs missing the audio features we aim to test. Missing these audio features breaks our testing metric making it hard to compare to the other models. For this reason, we decided to omit normalization of tempo.</p>


            <h5>Works Cited</h5>
              <ol>
                 <li>
                    <p>K, Dhiraj. “Difference between K-Nearest Neighbor(K-NN) and K-Means Clustering.” Medium, Medium, 29 Aug. 2019, <br>medium.com/@dhiraj8899/difference-between-k-nearest-neighbor-k-nn-and-k-means-clustering-d9a44859182f.</p>
                 </li>
                 <li>
                    <p>“K-Means Clustering.” Wikipedia, Wikimedia Foundation, 3 Dec. 2019, <br> en.wikipedia.org/wiki/K-means_clustering.</p>
                 </li>
                 <li>
                    <p>“Machine Learning Basics with the K-Nearest Neighbors Algorithm.” Accessed December 9, 2019. <br>https://towardsdatascience.com/machine-learning-basics-with-the-k-nearest-neighbors-algorithm-6a6e71d01761.</p>
                 </li>
                 <li>
                     <p>“NP-Hardness.” Wikipedia, Wikimedia Foundation, 20 Nov. 2019, <br>https://en.wikipedia.org/wiki/NP-hardness.</p>
                 </li>
                 <li>
                     <p>“Rocchio Algorithm.” Wikipedia, Wikimedia Foundation, 3 Nov. 2019, <br>https://en.wikipedia.org/wiki/Rocchio_algorithm.</p>
                 </li>
              </ol>
        </div>

        <div class="section pp-scrollable">
            <h1>Results: Evaluating our playlists</h1>
            <p>Once we had created our playlists using our K-NN and K-Means models, we created two main testing methods by which to evaluate the quality of our playlists. These methods and their results are described in this section of our report. </p>
            <br/>
            <h3>Method 1: Cluster Evaluation</h3>
            <p>The first  </p>
            <h3>Method 2: User-Created Playlist Audio Features</h3>

        </div>

        <div class="section">
            <h1>Conclusions</h1>
            <p></p>
        </div>
        <div class="section">
            <h1>Full Bibliography</h1>
		      <ol>
                <li>
                    <p>K, Dhiraj. “Difference between K-Nearest Neighbor(K-NN) and K-Means Clustering.” Medium, Medium, 29 Aug. 2019, <br>medium.com/@dhiraj8899/difference-between-k-nearest-neighbor-k-nn-and-k-means-clustering-d9a44859182f.</p>
                 </li>
                <li>
                     <p>Dieleman, Sander. “Recommending Music on Spotify with Deep Learning.” Accessed December 9, 2019. <br>https://benanne.github.io/2014/08/05/spotify-cnns.html.</p>
                 </li>
                <li>
                    <p>Giacaglia, Giuliano. “Behind Spotify Recommendation Engine.” Medium, May 21, 2019. <br> https://medium.com/datadriveninvestor/behind-spotify-recommendation-engine-a9b5a27a935.</p>
                 </li>
                <li>
                    <p>Johnson, Chris. “Algorithmic Music Recommendations at Spotify.” Technology, 11:33:57 UTC. <br> https://www.slideshare.net/MrChrisJohnson/algorithmic-music-recommendations-at-spotify/3-What_is_SpotifyOn_demand_music.</p>
                 </li>
		         <li>
		            <p>Porter, “Spotify Is First to 100 Million Paid Subscribers.”</p>
		         </li>
		         <li>
		            <p>“Discover Weekly: How Spotify Is Changing the Way We Consume Music – Technology and Operations Management.”</p>
		         </li>

                 <li>
                    <p>“K-Means Clustering.” Wikipedia, Wikimedia Foundation, 3 Dec. 2019, <br> en.wikipedia.org/wiki/K-means_clustering.</p>
                 </li>
                 <li>
                    <p>“Machine Learning Basics with the K-Nearest Neighbors Algorithm.” Accessed December 9, 2019. <br>https://towardsdatascience.com/machine-learning-basics-with-the-k-nearest-neighbors-algorithm-6a6e71d01761.</p>
                 </li>
                 <li>
                     <p>“NP-Hardness.” Wikipedia, Wikimedia Foundation, 20 Nov. 2019, <br>https://en.wikipedia.org/wiki/NP-hardness.</p>
                 </li>
                 <li>
                     <p>“Rocchio Algorithm.” Wikipedia, Wikimedia Foundation, 3 Nov. 2019, <br>https://en.wikipedia.org/wiki/Rocchio_algorithm.</p>
                 </li>
		      </ol>
        </div>
    </div>

    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
<!--    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>-->
    <script src="js/jquery.pagepiling.min.js"></script>
    <script src="js/d3.min.js"></script>
    <script src="js/main.js"></script>
</body>
</html>